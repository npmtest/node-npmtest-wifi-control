{"/home/travis/build/npmtest/node-npmtest-wifi-control/test.js":"/* istanbul instrument in package npmtest_wifi_control */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-wifi-control/lib.npmtest_wifi_control.js":"/* istanbul instrument in package npmtest_wifi_control */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_wifi_control = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_wifi_control = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-wifi-control/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-wifi-control && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_wifi_control */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_wifi_control\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_wifi_control.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_wifi_control.rollup.js'] =\n            local.assetsDict['/assets.npmtest_wifi_control.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_wifi_control.__dirname + '/lib.npmtest_wifi_control.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-wifi-control/node_modules/wifi-control/lib/wifi-control.js":"// Generated by CoffeeScript 1.12.4\n(function() {\n  var CXT, WiFiScanner, execSyncToBuffer, os_instructions;\n\n  WiFiScanner = require('node-wifiscanner2');\n\n  execSyncToBuffer = require('sync-exec');\n\n  CXT = {\n    WiFiControlSettings: {\n      iface: null,\n      debug: false,\n      connectionTimeout: 5000\n    },\n    execSync: function(command, options) {\n      var results;\n      if (options == null) {\n        options = {};\n      }\n      results = execSyncToBuffer(command, options);\n      if (!results.status) {\n        return results.stdout;\n      }\n      throw {\n        stderr: results.stderr\n      };\n    },\n    WiFiLog: function(msg, error) {\n      if (error == null) {\n        error = false;\n      }\n      if (error) {\n        return console.error(\"WiFiControl: \" + msg);\n      } else {\n        if (this.WiFiControlSettings.debug) {\n          return console.log(\"WiFiControl: \" + msg);\n        }\n      }\n    }\n  };\n\n  switch (process.platform) {\n    case \"linux\":\n      os_instructions = require('./linux.js');\n      break;\n    case \"win32\":\n      os_instructions = require('./win32.js');\n      break;\n    case \"darwin\":\n      os_instructions = require('./darwin.js');\n      break;\n    default:\n      CXT.WiFiLog(\"Unrecognized operating system.\", true);\n      process.exit();\n  }\n\n  module.exports = {\n    init: function(settings) {\n      if (settings == null) {\n        settings = {};\n      }\n      this.configure(settings);\n      if (settings.iface == null) {\n        return this.findInterface(settings.iface);\n      }\n    },\n    configure: function(settings) {\n      if (settings == null) {\n        settings = {};\n      }\n      if (settings.debug != null) {\n        CXT.WiFiControlSettings.debug = settings.debug;\n        CXT.WiFiLog(\"Debug mode set to: \" + settings.debug);\n      }\n      if (settings.connectionTimeout != null) {\n        settings.connectionTimeout = parseInt(settings.connectionTimeout);\n        CXT.WiFiControlSettings.connectionTimeout = settings.connectionTimeout;\n        CXT.WiFiLog(\"AP connection attempt timeout set to: \" + settings.connectionTimeout + \"ms\");\n      }\n      if (settings.iface != null) {\n        return this.findInterface(settings.iface);\n      }\n    },\n    findInterface: function(iface) {\n      var _msg, error, interfaceResults;\n      if (iface == null) {\n        iface = null;\n      }\n      try {\n        if (iface != null) {\n          _msg = \"Wireless interface manually set to \" + iface + \".\";\n          CXT.WiFiLog(_msg);\n          CXT.WiFiControlSettings.iface = iface;\n          return {\n            success: true,\n            msg: _msg,\n            \"interface\": iface\n          };\n        }\n        CXT.WiFiLog(\"Determining system wireless interface...\");\n        interfaceResults = os_instructions.autoFindInterface.call(CXT);\n        CXT.WiFiControlSettings.iface = interfaceResults[\"interface\"];\n        return interfaceResults;\n      } catch (error1) {\n        error = error1;\n        _msg = \"Encountered an error while searching for wireless interface: \" + error;\n        CXT.WiFiLog(_msg, true);\n        return {\n          success: false,\n          msg: _msg\n        };\n      }\n    },\n    scanForWiFi: function(cb) {\n      var _msg, error, networks;\n      if (CXT.WiFiControlSettings.iface == null) {\n        _msg = \"You cannot scan for nearby WiFi networks without a valid wireless interface.\";\n        CXT.WiFiLog(_msg, true);\n        return {\n          success: false,\n          msg: _msg\n        };\n      }\n      try {\n        CXT.WiFiLog(\"Scanning for nearby WiFi Access Points...\");\n        if (process.platform === \"linux\") {\n          networks = os_instructions.scanForWiFi.apply(CXT);\n          _msg = \"Nearby WiFi APs successfully scanned (\" + networks.length + \" found).\";\n          CXT.WiFiLog(_msg);\n          return cb(null, {\n            success: true,\n            msg: _msg,\n            networks: networks\n          });\n        } else {\n          return WiFiScanner.scan(function(err, networks) {\n            if (err) {\n              _msg = \"We encountered an error while scanning for WiFi APs: \" + error;\n              CXT.WiFiLog(_msg, true);\n              return cb(err, {\n                success: false,\n                msg: _msg\n              });\n            } else {\n              _msg = \"Nearby WiFi APs successfully scanned (\" + networks.length + \" found).\";\n              CXT.WiFiLog(_msg);\n              return cb(null, {\n                success: true,\n                networks: networks,\n                msg: _msg\n              });\n            }\n          });\n        }\n      } catch (error1) {\n        error = error1;\n        _msg = \"We encountered an error while scanning for WiFi APs: \" + error;\n        CXT.WiFiLog(_msg, true);\n        return cb(error, {\n          success: false,\n          msg: _msg\n        });\n      }\n    },\n    connectToAP: function(_ap, cb) {\n      var _msg, check_iface, error, request_msg, t0;\n      if (CXT.WiFiControlSettings.iface == null) {\n        _msg = \"You cannot connect to a WiFi network without a valid wireless interface.\";\n        CXT.WiFiLog(_msg, true);\n        return {\n          success: false,\n          msg: _msg\n        };\n      }\n      try {\n        if (!_ap.ssid.length) {\n          return {\n            success: false,\n            msg: \"Please provide a non-empty SSID.\"\n          };\n        }\n        if (_ap.password == null) {\n          _ap.password = \"\";\n        }\n        os_instructions.connectToAP.call(CXT, _ap);\n        request_msg = \"WiFi connection request to \\\"\" + _ap.ssid + \"\\\" has been processed.\";\n        CXT.WiFiLog(request_msg);\n        t0 = new Date();\n        check_iface = (function(_this) {\n          return function(_ap, cb) {\n            var connect_to_ap_result, ifaceState;\n            ifaceState = _this.getIfaceState();\n            if (ifaceState.success && ((ifaceState.connection === \"connected\") || (ifaceState.connection === \"disconnected\"))) {\n              if (ifaceState.ssid === _ap.ssid) {\n                _msg = \"Successfully connected to \\\"\" + _ap.ssid + \"\\\"\";\n                CXT.WiFiLog(_msg);\n                cb(null, {\n                  success: true,\n                  msg: _msg\n                });\n              } else if (ifaceState.ssid == null) {\n                _msg = \"Error: Interface is not currently connected to any wireless AP.\";\n                CXT.WiFiLog(_msg, true);\n                cb(_msg, {\n                  success: false,\n                  msg: \"Error: Could not connect to \" + _ap.ssid\n                });\n              } else {\n                _msg = \"Error: Interface is currently connected to \\\"\" + ifaceState.ssid + \"\\\"\";\n                CXT.WiFiLog(_msg, true);\n                connect_to_ap_result = {\n                  success: false,\n                  msg: _msg\n                };\n                cb(_msg, {\n                  success: false,\n                  msg: \"Error: Could not connect to \" + _ap.ssid\n                });\n              }\n              return;\n            }\n            if ((new Date() - t0) < CXT.WiFiControlSettings.connectionTimeout) {\n              return setTimeout(function() {\n                return check_iface(_ap, cb);\n              }, 250);\n            } else {\n              return cb(\"Connection confirmation timed out. (\" + CXT.WiFiControlSettings.connectionTimeout + \"ms)\", {\n                success: false,\n                msg: \"Error: Could not connect to \" + _ap.ssid\n              });\n            }\n          };\n        })(this);\n        return check_iface(_ap, cb);\n      } catch (error1) {\n        error = error1;\n        _msg = \"Encountered an error while connecting to \\\"\" + _ap.ssid + \"\\\": \" + error;\n        CXT.WiFiLog(_msg, true);\n        return cb(error, {\n          success: false,\n          msg: _msg\n        });\n      }\n    },\n    resetWiFi: function(cb) {\n      var _msg, check_iface, error, t0;\n      try {\n        os_instructions.resetWiFi.call(CXT);\n        CXT.WiFiLog(\"Waiting for interface to finish resetting...\");\n        t0 = new Date();\n        check_iface = (function(_this) {\n          return function(cb) {\n            var _msg, ifaceState;\n            ifaceState = _this.getIfaceState();\n            if (ifaceState.success && ((ifaceState.connection === \"connected\") || (ifaceState.connection === \"disconnected\"))) {\n              _msg = \"Success!  Wireless interface is now reset.\";\n              cb(null, {\n                success: true,\n                msg: _msg\n              });\n              return;\n            }\n            if ((new Date() - t0) < CXT.WiFiControlSettings.connectionTimeout) {\n              return setTimeout(function() {\n                return check_iface(cb);\n              }, 250);\n            } else {\n              return cb(\"Reset confirmation timed out. (\" + CXT.WiFiControlSettings.connectionTimeout + \"ms)\", {\n                success: false,\n                msg: \"Error: Could not completely reset WiFi.\"\n              });\n            }\n          };\n        })(this);\n        return check_iface(cb);\n      } catch (error1) {\n        error = error1;\n        _msg = \"Encountered an error while resetting wireless interface: \" + error;\n        CXT.WiFiLog(_msg, true);\n        return cb(error, {\n          success: false,\n          msg: _msg\n        });\n      }\n    },\n    getIfaceState: function() {\n      var _msg, error, interfaceState;\n      try {\n        interfaceState = os_instructions.getIfaceState.call(CXT);\n        if (interfaceState.success !== false) {\n          interfaceState.success = true;\n          interfaceState.msg = \"Successfully acquired state of network interface \" + CXT.WiFiControlSettings.iface + \".\";\n        }\n        return interfaceState;\n      } catch (error1) {\n        error = error1;\n        _msg = \"Encountered an error while acquiring network interface connection state: \" + error;\n        CXT.WiFiLog(_msg, true);\n        return {\n          success: false,\n          msg: _msg\n        };\n      }\n    }\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-wifi-control/node_modules/wifi-control/lib/linux.js":"// Generated by CoffeeScript 1.12.4\n(function() {\n  var connectionStateMap, parsePatterns, powerStateMap;\n\n  parsePatterns = {\n    nmcli_line: new RegExp(/([^:]+):\\s+(.+)/)\n  };\n\n  connectionStateMap = {\n    connected: \"connected\",\n    disconnected: \"disconnected\",\n    connecting: \"connecting\"\n  };\n\n  powerStateMap = {\n    enabled: true,\n    disabled: false\n  };\n\n  module.exports = {\n    autoFindInterface: function() {\n      var _iface, _interface, _interfaceLine, _msg, findInterfaceCom, parsedLine;\n      this.WiFiLog(\"Host machine is Linux.\");\n      findInterfaceCom = \"nmcli -m multiline device status | grep wlan\";\n      this.WiFiLog(\"Executing: \" + findInterfaceCom);\n      _interfaceLine = this.execSync(findInterfaceCom);\n      parsedLine = parsePatterns.nmcli_line.exec(_interfaceLine.trim());\n      _interface = parsedLine[2];\n      if (_interface) {\n        _iface = _interface.trim();\n        _msg = \"Automatically located wireless interface \" + _iface + \".\";\n        this.WiFiLog(_msg);\n        return {\n          success: true,\n          msg: _msg,\n          \"interface\": _iface\n        };\n      } else {\n        _msg = \"Error: No network interface found.\";\n        this.WiFiLog(_msg, true);\n        return {\n          success: false,\n          msg: _msg,\n          \"interface\": null\n        };\n      }\n    },\n    getIfaceState: function() {\n      var KEY, VALUE, connectionData, connectionName, error, foundInterface, i, interfaceState, k, len, ln, parsedLine, powerData, ref, ssidData;\n      interfaceState = {};\n      powerData = this.execSync(\"nmcli networking\");\n      interfaceState.power = powerStateMap[powerData.trim()];\n      if (interfaceState.power) {\n        foundInterface = false;\n        connectionData = this.execSync(\"nmcli -m multiline device status\");\n        connectionName = null;\n        ref = connectionData.split('\\n');\n        for (k = i = 0, len = ref.length; i < len; k = ++i) {\n          ln = ref[k];\n          try {\n            parsedLine = parsePatterns.nmcli_line.exec(ln.trim());\n            KEY = parsedLine[1];\n            VALUE = parsedLine[2];\n            if (VALUE === \"--\") {\n              VALUE = null;\n            }\n          } catch (error1) {\n            error = error1;\n            continue;\n          }\n          switch (KEY) {\n            case \"DEVICE\":\n              if (VALUE === this.WiFiControlSettings.iface) {\n                foundInterface = true;\n              }\n              break;\n            case \"STATE\":\n              if (foundInterface) {\n                interfaceState.connection = connectionStateMap[VALUE];\n              }\n              break;\n            case \"CONNECTION\":\n              if (foundInterface) {\n                connectionName = VALUE;\n              }\n          }\n          if (KEY === \"CONNECTION\" && foundInterface) {\n            break;\n          }\n        }\n        if (!foundInterface) {\n          return {\n            success: false,\n            msg: \"Unable to retrieve state of network interface \" + this.WiFiControlSettings.iface + \".\"\n          };\n        }\n        if (connectionName) {\n          try {\n            ssidData = this.execSync(\"nmcli -m multiline connection show \\\"\" + connectionName + \"\\\" | grep 802-11-wireless.ssid\");\n            parsedLine = parsePatterns.nmcli_line.exec(ssidData.trim());\n            interfaceState.ssid = parsedLine[2];\n          } catch (error1) {\n            error = error1;\n            return {\n              success: false,\n              msg: \"Error while retrieving SSID information of network interface \" + this.WiFiControlSettings.iface + \": \" + error.stderr\n            };\n          }\n        } else {\n          interfaceState.ssid = null;\n        }\n      } else {\n        interfaceState.connection = connectionStateMap[VALUE];\n        interfaceState.ssid = null;\n      }\n      return interfaceState;\n    },\n    scanForWiFi: function() {\n      var KEY, VALUE, _network, c, error, i, j, k, len, len1, ln, networks, nwk, parsedLine, ref, ref1, scanResults;\n      scanResults = this.execSync(\"nmcli -m multiline device wifi list ifname \" + this.WiFiControlSettings.iface);\n      networks = [];\n      ref = scanResults.split('*:');\n      for (c = i = 0, len = ref.length; i < len; c = ++i) {\n        nwk = ref[c];\n        if (c === 0) {\n          continue;\n        }\n        _network = {};\n        ref1 = nwk.split('\\n');\n        for (k = j = 0, len1 = ref1.length; j < len1; k = ++j) {\n          ln = ref1[k];\n          try {\n            parsedLine = parsePatterns.nmcli_line.exec(ln.trim());\n            KEY = parsedLine[1];\n            VALUE = parsedLine[2];\n          } catch (error1) {\n            error = error1;\n            continue;\n          }\n          switch (KEY) {\n            case \"SSID\":\n              _network.ssid = String(VALUE);\n              break;\n            case \"CHAN\":\n              _network.channel = String(VALUE);\n              break;\n            case \"SIGNAL\":\n              _network.signal_level = String(VALUE);\n              break;\n            case \"SECURITY\":\n              _network.security = String(VALUE);\n          }\n        }\n        if (_network.ssid !== \"--\") {\n          networks.push(_network);\n        }\n      }\n      return networks;\n    },\n    connectToAP: function(_ap) {\n      var COMMANDS, _msg, com, connectToAPChain, error, i, len, ssidExist, stdout;\n      COMMANDS = {\n        \"delete\": \"nmcli connection delete \\\"\" + _ap.ssid + \"\\\"\",\n        connect: \"nmcli device wifi connect \\\"\" + _ap.ssid + \"\\\"\"\n      };\n      if (_ap.password.length) {\n        COMMANDS.connect += \" password \\\"\" + _ap.password + \"\\\"\";\n      }\n      try {\n        stdout = this.execSync(\"nmcli connection show \\\"\" + _ap.ssid + \"\\\"\");\n        if (stdout.length) {\n          ssidExist = true;\n        }\n      } catch (error1) {\n        error = error1;\n        ssidExist = false;\n      }\n      connectToAPChain = [];\n      if (ssidExist) {\n        this.WiFiLog(\"It appears there is already a connection for this SSID.\");\n        connectToAPChain.push(\"delete\");\n      }\n      connectToAPChain.push(\"connect\");\n      for (i = 0, len = connectToAPChain.length; i < len; i++) {\n        com = connectToAPChain[i];\n        this.WiFiLog(\"Executing:\\t\" + COMMANDS[com]);\n        try {\n          stdout = this.execSync(COMMANDS[com]);\n        } catch (error1) {\n          error = error1;\n          if (error.stderr.toString().trim() === (\"Error: No network with SSID '\" + _ap.ssid + \"' found.\")) {\n            _msg = \"Error: No network called \" + _ap.ssid + \" could be found.\";\n            this.WiFiLog(_msg, true);\n            return {\n              success: false,\n              msg: _msg\n            };\n          } else if (error.stderr.toString().search(/Error:/ !== -1)) {\n            _msg = error.stderr.toString().trim();\n            this.WiFiLog(_msg, true);\n            return {\n              success: false,\n              msg: _msg\n            };\n          }\n          if (!/nmcli device wifi connect/.test(COMMANDS[com])) {\n            this.WiFiLog(error, true);\n            return {\n              success: false,\n              msg: error\n            };\n          }\n        }\n        this.WiFiLog(\"Success!\");\n      }\n    },\n    resetWiFi: function() {\n      var COMMANDS, _msg, com, i, len, resetWiFiChain, results, stdout;\n      COMMANDS = {\n        disableNetworking: \"nmcli networking off\",\n        enableNetworking: \"nmcli networking on\"\n      };\n      resetWiFiChain = [\"disableNetworking\", \"enableNetworking\"];\n      results = [];\n      for (i = 0, len = resetWiFiChain.length; i < len; i++) {\n        com = resetWiFiChain[i];\n        this.WiFiLog(\"Executing:\\t\" + COMMANDS[com]);\n        stdout = this.execSync(COMMANDS[com]);\n        _msg = \"Success!\";\n        results.push(this.WiFiLog(_msg));\n      }\n      return results;\n    }\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-wifi-control/node_modules/wifi-control/lib/darwin.js":"// Generated by CoffeeScript 1.12.4\n(function() {\n  var AirPortBinary, connectionStateMap, parsePatterns, powerStateMap;\n\n  AirPortBinary = \"/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport\";\n\n  parsePatterns = {\n    airport_line: new RegExp(/(.+): (.+)/)\n  };\n\n  connectionStateMap = {\n    init: \"disconnected\",\n    running: \"connected\"\n  };\n\n  powerStateMap = {\n    On: true,\n    Off: false\n  };\n\n  module.exports = {\n    autoFindInterface: function() {\n      var _iface, _interface, _msg, findInterfaceCom;\n      this.WiFiLog(\"Host machine is MacOS.\");\n      findInterfaceCom = \"networksetup -listallhardwareports | awk '/^Hardware Port: (Wi-Fi|AirPort)$/{getline;print $2}'\";\n      this.WiFiLog(\"Executing: \" + findInterfaceCom);\n      _interface = this.execSync(findInterfaceCom);\n      if (_interface) {\n        _iface = _interface.trim();\n        _msg = \"Automatically located wireless interface \" + _iface + \".\";\n        this.WiFiLog(_msg);\n        return {\n          success: true,\n          msg: _msg,\n          \"interface\": _iface\n        };\n      } else {\n        _msg = \"Error: No network interface found.\";\n        this.WiFiLog(_msg, true);\n        return {\n          success: false,\n          msg: _msg,\n          \"interface\": null\n        };\n      }\n    },\n    getIfaceState: function() {\n      var KEY, VALUE, connectionData, error, i, interfaceState, k, len, ln, parsedLine, powerData, ref;\n      interfaceState = {};\n      connectionData = this.execSync(AirPortBinary + \" -I\");\n      ref = connectionData.split('\\n');\n      for (k = i = 0, len = ref.length; i < len; k = ++i) {\n        ln = ref[k];\n        try {\n          parsedLine = parsePatterns.airport_line.exec(ln.trim());\n          KEY = parsedLine[1];\n          VALUE = parsedLine[2];\n        } catch (error1) {\n          error = error1;\n          continue;\n        }\n        switch (KEY) {\n          case \"state\":\n            interfaceState.connection = connectionStateMap[VALUE];\n            break;\n          case \"SSID\":\n            interfaceState.ssid = VALUE;\n        }\n        if (KEY === \"SSID\") {\n          break;\n        }\n      }\n      powerData = this.execSync(\"networksetup -getairportpower \" + this.WiFiControlSettings.iface);\n      try {\n        parsedLine = parsePatterns.airport_line.exec(powerData.trim());\n        KEY = parsedLine[1];\n        VALUE = parsedLine[2];\n      } catch (error1) {\n        error = error1;\n        return {\n          success: false,\n          msg: \"Unable to retrieve state of network interface \" + this.WiFiControlSettings.iface + \".\"\n        };\n      }\n      interfaceState.power = powerStateMap[VALUE];\n      return interfaceState;\n    },\n    connectToAP: function(_ap) {\n      var COMMANDS, _msg, com, connectToAPChain, error, i, len, stdout;\n      COMMANDS = {\n        connect: \"networksetup -setairportnetwork \" + this.WiFiControlSettings.iface + \" \\\"\" + _ap.ssid + \"\\\"\"\n      };\n      if (_ap.password.length) {\n        COMMANDS.connect += \" \\\"\" + _ap.password + \"\\\"\";\n      }\n      connectToAPChain = [\"connect\"];\n      for (i = 0, len = connectToAPChain.length; i < len; i++) {\n        com = connectToAPChain[i];\n        this.WiFiLog(\"Executing:\\t\" + COMMANDS[com]);\n        try {\n          stdout = this.execSync(COMMANDS[com]);\n        } catch (error1) {\n          error = error1;\n        }\n        if (stdout === (\"Could not find network \" + _ap.ssid + \".\")) {\n          _msg = \"Error: No network called \" + _ap.ssid + \" could be found.\";\n          this.WiFiLog(_msg, true);\n          return {\n            success: false,\n            msg: _msg\n          };\n        }\n        this.WiFiLog(\"Success!\");\n      }\n    },\n    resetWiFi: function() {\n      var COMMANDS, _msg, com, i, len, resetWiFiChain, results, stdout;\n      COMMANDS = {\n        enableAirport: \"networksetup -setairportpower \" + this.WiFiControlSettings.iface + \" on\",\n        disableAirport: \"networksetup -setairportpower \" + this.WiFiControlSettings.iface + \" off\"\n      };\n      resetWiFiChain = [\"disableAirport\", \"enableAirport\"];\n      results = [];\n      for (i = 0, len = resetWiFiChain.length; i < len; i++) {\n        com = resetWiFiChain[i];\n        this.WiFiLog(\"Executing:\\t\" + COMMANDS[com]);\n        stdout = this.execSync(COMMANDS[com]);\n        _msg = \"Success!\";\n        results.push(this.WiFiLog(_msg));\n      }\n      return results;\n    }\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-wifi-control/node_modules/wifi-control/lib/win32.js":"// Generated by CoffeeScript 1.12.4\n(function() {\n  var connectionStateMap, fs, parsePatterns, win32WirelessProfileBuilder;\n\n  fs = require('fs');\n\n  parsePatterns = {\n    netsh_line: new RegExp(/([^:]+): (.+)/)\n  };\n\n  connectionStateMap = {\n    connected: \"connected\",\n    disconnected: \"disconnected\",\n    associating: \"connecting\"\n  };\n\n  win32WirelessProfileBuilder = function(ssid, security, key) {\n    var profile_content;\n    if (security == null) {\n      security = false;\n    }\n    if (key == null) {\n      key = null;\n    }\n    profile_content = \"<?xml version=\\\"1.0\\\"?> <WLANProfile xmlns=\\\"http://www.microsoft.com/networking/WLAN/profile/v1\\\"> <name>\" + ssid.plaintext + \"</name> <SSIDConfig> <SSID> <hex>\" + ssid.hex + \"</hex> <name>\" + ssid.plaintext + \"</name> </SSID> </SSIDConfig>\";\n    switch (security) {\n      case \"wpa\":\n        profile_content += \"<connectionType>ESS</connectionType> <connectionMode>auto</connectionMode> <autoSwitch>true</autoSwitch> <MSM> <security> <authEncryption> <authentication>WPAPSK</authentication> <encryption>TKIP</encryption> <useOneX>false</useOneX> </authEncryption> <sharedKey> <keyType>passPhrase</keyType> <protected>false</protected> <keyMaterial>\" + key + \"</keyMaterial> </sharedKey> </security> </MSM>\";\n        break;\n      case \"wpa2\":\n        profile_content += \"<connectionType>ESS</connectionType> <connectionMode>auto</connectionMode> <autoSwitch>true</autoSwitch> <MSM> <security> <authEncryption> <authentication>WPA2PSK</authentication> <encryption>AES</encryption> <useOneX>false</useOneX> </authEncryption> <sharedKey> <keyType>passPhrase</keyType> <protected>false</protected> <keyMaterial>\" + key + \"</keyMaterial> </sharedKey> </security> </MSM>\";\n        break;\n      default:\n        profile_content += \"<connectionType>ESS</connectionType> <connectionMode>manual</connectionMode> <MSM> <security> <authEncryption> <authentication>open</authentication> <encryption>none</encryption> <useOneX>false</useOneX> </authEncryption> </security> </MSM>\";\n    }\n    profile_content += \"</WLANProfile>\";\n    return profile_content;\n  };\n\n  module.exports = {\n    autoFindInterface: function() {\n      var _iface, _interface, _msg, findInterfaceCom;\n      this.WiFiLog(\"Host machine is Windows.\");\n      findInterfaceCom = \"echo wlan\";\n      this.WiFiLog(\"Executing: \" + findInterfaceCom);\n      _interface = this.execSync(findInterfaceCom);\n      if (_interface) {\n        _iface = _interface.trim();\n        _msg = \"Automatically located wireless interface \" + _iface + \".\";\n        this.WiFiLog(_msg);\n        return {\n          success: true,\n          msg: _msg,\n          \"interface\": _iface\n        };\n      } else {\n        _msg = \"Error: No network interface found.\";\n        this.WiFiLog(_msg, true);\n        return {\n          success: false,\n          msg: _msg,\n          \"interface\": null\n        };\n      }\n    },\n    getIfaceState: function() {\n      var KEY, VALUE, connectionData, error, interfaceState, j, k, len, ln, ln_trim, parsedLine, ref;\n      interfaceState = {};\n      connectionData = this.execSync(\"netsh \" + this.WiFiControlSettings.iface + \" show interface\");\n      ref = connectionData.split('\\n');\n      for (k = j = 0, len = ref.length; j < len; k = ++j) {\n        ln = ref[k];\n        try {\n          ln_trim = ln.trim();\n          if (ln_trim === \"Software Off\") {\n            interfaceState = {\n              ssid: null,\n              connected: false,\n              power: false\n            };\n            break;\n          } else {\n            parsedLine = parsePatterns.netsh_line.exec(ln_trim);\n            KEY = parsedLine[1].trim();\n            VALUE = parsedLine[2].trim();\n          }\n        } catch (error1) {\n          error = error1;\n          continue;\n        }\n        interfaceState.power = true;\n        switch (KEY) {\n          case \"State\":\n            interfaceState.connection = connectionStateMap[VALUE];\n            break;\n          case \"SSID\":\n            interfaceState.ssid = VALUE;\n            break;\n          case \"Radio status\":\n            if (VALUE === \"Hardware Off\") {\n              interfaceState = {\n                ssid: null,\n                connected: false,\n                power: false\n              };\n              break;\n            }\n        }\n        if (KEY === \"SSID\") {\n          break;\n        }\n      }\n      return interfaceState;\n    },\n    connectToAP: function(_ap) {\n      var COMMANDS, _msg, com, connectToAPChain, error, i, j, l, len, ref, ssid, stdout, xmlContent;\n      this.WiFiLog(\"Generating win32 wireless profile...\");\n      ssid = {\n        plaintext: _ap.ssid,\n        hex: \"\"\n      };\n      for (i = j = 0, ref = ssid.plaintext.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {\n        ssid.hex += ssid.plaintext.charCodeAt(i).toString(16);\n      }\n      xmlContent = null;\n      if (_ap.password.length) {\n        xmlContent = win32WirelessProfileBuilder(ssid, \"wpa2\", _ap.password);\n      } else {\n        xmlContent = win32WirelessProfileBuilder(ssid);\n      }\n      try {\n        fs.writeFileSync(_ap.ssid + \".xml\", xmlContent);\n      } catch (error1) {\n        error = error1;\n        _msg = \"Encountered an error connecting to AP: \" + error;\n        this.WiFiLog(_msg, true);\n        return {\n          success: false,\n          msg: _msg\n        };\n      }\n      COMMANDS = {\n        loadProfile: \"netsh \" + this.WiFiControlSettings.iface + \" add profile filename=\\\"\" + _ap.ssid + \".xml\\\"\",\n        connect: \"netsh \" + this.WiFiControlSettings.iface + \" connect ssid=\\\"\" + _ap.ssid + \"\\\" name=\\\"\" + _ap.ssid + \"\\\"\"\n      };\n      connectToAPChain = [\"loadProfile\", \"connect\"];\n      for (l = 0, len = connectToAPChain.length; l < len; l++) {\n        com = connectToAPChain[l];\n        this.WiFiLog(\"Executing:\\t\" + COMMANDS[com]);\n        try {\n          stdout = this.execSync(COMMANDS[com]);\n        } catch (error1) {\n          error = error1;\n        }\n        this.WiFiLog(\"Success!\");\n      }\n      this.WiFiLog(\"Removing temporary WiFi config file...\");\n      return this.execSync(\"del \\\".\\\\\" + _ap.ssid + \".xml\\\"\");\n    },\n    resetWiFi: function() {\n      var COMMANDS, _msg, com, j, len, resetWiFiChain, results, stdout;\n      COMMANDS = {\n        disconnect: \"netsh \" + this.WiFiControlSettings.iface + \" disconnect\"\n      };\n      resetWiFiChain = [\"disconnect\"];\n      results = [];\n      for (j = 0, len = resetWiFiChain.length; j < len; j++) {\n        com = resetWiFiChain[j];\n        this.WiFiLog(\"Executing:\\t\" + COMMANDS[com]);\n        stdout = this.execSync(COMMANDS[com]);\n        _msg = \"Success!\";\n        results.push(this.WiFiLog(_msg));\n      }\n      return results;\n    }\n  };\n\n}).call(this);\n"}